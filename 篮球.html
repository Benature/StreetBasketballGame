<!DOCTYPE html>
<html>
<head>
    <title>篮球跳跃</title>
    <meta charset="utf-8">
</head>
<body>
<canvas id="myCanvas1" width="1500" height="700" style="border:solid;position: absolute;z-index: 0">
    你的浏览器不支持canvas画布元素，请更新浏览器获得演示效果。
</canvas>

<script type="text/javascript">
    var canvas = document.getElementById("myCanvas1");
    var context = canvas.getContext("2d");
    context.font = "20px Arial";
    
    var ball={x:100,y:250,r:40};//篮球ball圆心坐标,半径
    var v_x = 0,
        v_y = 1;//球分解速度
    var fre=0.5;//帧率
    var g   = 1;//重力加速度
    var wind   = 0.5;//台风横向加速度
    var af  = 5;//空气阻力
    var groundy = 600;//地面y值
    var t = 0;//时间(迭代)
    var mouseX,mouseY;//鼠标点击坐标

    var LevelMove;//水平移动真假判断
    var lor;
    var propsplace_x1;//小道具的随机xy坐标
    var propsplace_y1 ;
    var propstime = 5;//小道具停留时间；
    var timelonger = 3;//加时时间。
    var propsplace_x2;//保存小道具坐标的变量；
    var propsplace_y2;
    var p_distance;//小道具与球的中心距离；
    var hua = true;
    var hua2 = false;
    var propstrigger;
    var t_iplus = 0;//道具加时。
    var t_i0 ;
    var ghost_x = new Array();
    var ghost_y = new Array();

    //点击鼠标触发弹起
    canvas.addEventListener("mousedown", function (e) {
        //console.log("mousedown");
        var back_y = 1
        v_y = 15;
        mouseX = e.pageX - canvas.clientLeft;
        mouseY = e.pageY - canvas.clientTop;
        //console.log(mouseX + "," + mouseY);
        LevelMove = true;
        lor = (mouseX > ball.x-ball.r)?(1):(-1);
        v_x = 10;
        //console.log(" now should LEVEL MOVE")

    }, false);

    //水平移动
    var level_move = function(){
        if (LevelMove) {
            //console.log("LEVEL MOVE!!!")
            ball.x += lor * v_x *fre;
            v_x -= wind;
            if (v_x <= 0) {LevelMove = false}
        }
    };

    //篮球弹跳
    var BBU = function(){
        //Ball Bounce Up
        //篮球自己弹起来
        //ball.y -=  ((v_y * t + 0.5 * g * t*t));
        ball.y -=  ((v_y * fre ));
        v_y -= (g * fre);
        if (ball.y >= groundy){
            //v_y = -v_y-1;
            v_y = 25;
        }
    }

    //篮球残影
    var ghost = function(){
        //记录坐标集合 
        if (t<=1*ball.r){
                ghost_x[t]=ball.x;
                ghost_y[t]=ball.y;
            }
            else{
                //坐标数据迭代退位
                for (var n = 0; n < 1*ball.r; n++){
                    ghost_x[n] = ghost_x[n+1];
                    ghost_y[n] = ghost_y[n+1];
                }
                //末位数据留给最新坐标
                ghost_x[1*ball.r]=ball.x;
                ghost_y[1*ball.r]=ball.y;
            }
            //画残影
            for (var i = 0; i <= ball.r; i++){
                context.beginPath();
                for (var n = 0; n < 1; n++){
                context.arc(ghost_x[1*i+n],ghost_y[1*i+n],i+1/1*n, 0, 360 * Math.PI / 180, true);
                }
                context.fillStyle = 'rgba(239, 129, 32, 0.1)';
                context.fill();
            }
    }
    var propsimage = new Image();
    propsimage.src ="clock.png";
    
    var props = function (){
         propsplace_x1 =  Math.random() * 200 + 100;//小道具的随机xy坐标
         propsplace_y1=  Math.random() * 200 + 100;
         context.drawImage(propsimage,0,0,300,300,propsplace_x1,propsplace_y1,100,100);
    }

    var ball_img = new Image();
    ball_img.src = "ball.png";
    ball_img.onload = function () {
        width = ball_img.width;
        height = ball_img.height;
        
    //篮板碰撞

    

    /*var distances = function (x,y){
        distances = ((ball.x+ball.r-x)*(ball.x+ball.r-x))+((ball.y-ball.r-y)*(ball.y-ball.r-y));
        
        return distances; 
        }*/
    

    var collision = function (){
        //单纯粗糙的碰板
        var board = {x:500,y:200,w:25,h:200};
        var between_x=(ball.x + 2*ball.r > board.x) && (ball.x < board.x + board.w);
        var between_y=(ball.y + 2 * ball.r > board.y) && (ball.y < board.y + board.h);
        if (between_x && between_y){
            lor = -2;
            v_y = -0.8  *v_y
            console.log('我TM撞上板了');
        }
        
        
    }
    
    
    
    //请开始我们的表演
        setInterval(function () {
            context.clearRect(0, 0, 1500, 700);
            //数据显示
            context.fillText("ball.y: "+ball.y,20,20);
            context.fillText("v_y: "+v_y,20,120);
            var t_i = 60-Math.ceil(t/60);
           
            //给界面加一个整数计时器。
            var t_itotal = t_i + t_iplus;
            context.fillText("时间:" + t_itotal,20,200) ;
            context.fillText("距离" + p_distance ,100,200) ;
            
            //篮球架
            context.beginPath();
            context.moveTo(500,200);
            context.lineTo(500,400);
            context.lineTo(525,400);
            context.lineTo(525,200);
            context.closePath();
            context.stroke();          

            //console.log("v_y: "+v_y);
        
            context.save();
            ghost();
            //篮球旋转
            context.translate(ball.x, ball.y);
            context.rotate((Math.PI/180)*t*1)
            context.drawImage(ball_img, 0, 0, 250,250,-ball.r,-ball.r,80,80);
            /*context.beginPath();context.arc(0, 0, 50, 0, 360 * Math.PI / 180, true);context.moveTo(0, 0);context.lineTo(0, 50);context.stroke();*/
            context.rotate(-(Math.PI/180)*t*1)
            context.translate(-ball.x,-ball.y);

            BBU();
            collision();
            level_move();
            
           propstrigger = Math.ceil(Math.random() * 200);
            console.log(propstrigger);
            hua = true;
            if(propstrigger === 199  ){
              props();
               propsplace_x2 = propsplace_x1;
               propsplace_y2 = propsplace_y1;
                t_i0 = t_i;
               }
         
                else if(   t_i >= t_i0 - 3){
               
               
                p_distance  =   Math.sqrt(Math.pow( ball_x - propsplace_x2,2) + Math.pow(ball_y - propsplace_y2,2) ); 
                if (p_distance >= 100 && hua){
                    context.drawImage(propsimage,0,0,300,300,propsplace_x2,propsplace_y2,100,100);
                    
              }
                else if (p_distance < 100){hua = false}
                }
                
            t++;
            
           if (hua === false && hua2 === false){
                t_iplus += 3;
                hua2 === true;

                
            }
            if (p_distance >= 100 ){
                
                hua2 = false;
            }
            

            //context.drawImage(ball, 0, 0, 290,285,ball.x,ball.y,100,98);
            //context.drawImage(ball, 0, 0, 290,285,200,200,100,98);
            context.restore();
            

        
        }, 1000 *1/ (60*3));
        

    };


</script>
</body>
</html>
