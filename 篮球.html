<!DOCTYPE html>
<html>
<head>
    <title>篮球跳跃</title>
    <meta charset="utf-8">
</head>
<body>
<canvas id="myCanvas1" width="1500" height="700" style="border:solid;position: absolute;z-index: 0">
    你的浏览器不支持canvas画布元素，请更新浏览器获得演示效果。
</canvas>

<script type="text/javascript">
    var canvas = document.getElementById("myCanvas1");
    var context = canvas.getContext("2d");
    context.font = "20px Arial";
    
    var ball={x:100,y:250,r:40};//篮球ball圆心坐标,半径
    var v_x = 0,
        v_y = 1;//球分解速度
    var fre=0.5;//帧率
    var g   = 1;//重力加速度
    var wind   = 0.5;//台风横向加速度
    var af  = 5;//空气阻力
    var groundy = 600;//地面y值
    var t = 0;//时间(迭代)
    var mouseX,mouseY;//鼠标点击坐标

    var LevelMove;//水平移动真假判断
    var lor;//判断水平移动左右
    var propsplace = {
        x1:0,y1:0,//小道具的随机xy坐标
        x2:0,y2:0,//保存小道具坐标的变量；
        distance:0,//小道具与球的中心距离；
        draw:true,//小道具是否出现
        t:5//小道具停留时间；
    };
    var ghost_x = new Array();
    var ghost_y = new Array();


    //点击鼠标触发弹起
    canvas.addEventListener("mousedown", function (e) {
        //console.log("mousedown");
        v_y = 15;
        mouseX = e.pageX - canvas.clientLeft;
        mouseY = e.pageY - canvas.clientTop;
        //console.log(mouseX + "," + mouseY);
        LevelMove = true;
        lor = (mouseX > ball.x-ball.r)?(1):(-1);
        v_x = 10;
        //console.log(" now should LEVEL MOVE")

    }, false);

    //水平移动
    var level_move = function(){
        if (LevelMove) {
            //console.log("LEVEL MOVE!!!")
            ball.x += lor * v_x*fre;
            v_x -= wind*fre;
            if (v_x <= 0) {LevelMove = false}
        }
    };

    //篮球弹跳
    var BBU = function(){
        //Ball Bounce Up
        //篮球自己弹起来
        //ball.y -=  ((v_y * t + 0.5 * g * t*t));
        ball.y -=  ((v_y * fre ));
        v_y -= (g * fre);
        if (ball.y >= groundy){
            //v_y = -v_y-1;
            v_y = 25;
        }
    }

    //篮球残影
    var ghost = function(){
        //记录坐标集合 
        if (t<=1*ball.r){
                ghost_x[t]=ball.x;
                ghost_y[t]=ball.y;
            }
            else{
                //坐标数据迭代退位
                for (var n = 0; n < 1*ball.r; n++){
                    ghost_x[n] = ghost_x[n+1];
                    ghost_y[n] = ghost_y[n+1];
                }
                //末位数据留给最新坐标
                ghost_x[1*ball.r]=ball.x;
                ghost_y[1*ball.r]=ball.y;
            }
            //画残影
            for (var i = 0; i <= ball.r; i++){
                context.beginPath();
                for (var n = 0; n < 1; n++){
                context.arc(ghost_x[1*i+n],ghost_y[1*i+n],i+1/1*n, 0, 360 * Math.PI / 180, true);
                }
                context.fillStyle = 'rgba(239, 129, 32, 0.1)';
                context.fill();
            }
    }
    var propsimage = new Image();
    propsimage.src ="face.png";
    
    var props = function (){
         propsplace.x1 =  Math.random() * 100 + 100;//小道具的随机xy坐标
         propsplace.y1=  Math.random() * 100 + 100;
         context.drawImage(propsimage,0,0,290,285,propsplace.x1,propsplace.y1,100,100);
    }
   /* propsimage.onload() = function(){
            width = propsimage.width ;
            height =propsimage.height;
            context.clearRect(0, 0, 1000, 1240);
            var i ;
            setInterval(function(){
            var chance = Math.random() * 10;
                if (chance <= 6 && chance >= 4 ){
                    props();
                    i = 1 / 180;
                }
                else i = 1;
             t++
            
             context2.restore();
            },1000 / 60 * i)
        }*/
    var ball_img = new Image();
    ball_img.src = "ball.png";
    ball_img.onload = function () {
        width = ball_img.width;
        height = ball_img.height;
        setInterval(function () {
            context.clearRect(0, 0, 1000, 1240);
            //数据显示
            context.fillText("ball.y: "+ball.y,20,20);
            context.fillText("v_y: "+v_y,20,120);
            var t_i = 60-Math.ceil(t/60);//给界面加一个整数计时器。
            context.fillText("时间:" + t_i ,20,200) ;
            context.fillText("距离" + propsplace.distance ,100,200) ;
          

            //console.log("v_y: "+v_y);
        
            context.save();
            ghost();
            //篮球旋转
            context.translate(ball.x, ball.y);
            context.rotate((Math.PI/180)*t*1)
            context.drawImage(ball_img, 0, 0, 250,250,-ball.r,-ball.r,80,80);
            /*context.beginPath();context.arc(0, 0, 50, 0, 360 * Math.PI / 180, true);context.moveTo(0, 0);context.lineTo(0, 50);context.stroke();*/
            context.rotate(-(Math.PI/180)*t*1)
            context.translate(-ball.x,-ball.y);

            BBU();
            
            level_move();
            if(t_i === 55){
              props();
               propsplace.x2 = propsplace.x1;
               propsplace.y2 = propsplace.y1;
            }
            else if(  t_i < 55 && t_i >= 55 - propsplace.t && propsplace.draw){
                //context.drawImage(propsimage,0,0,290,285,propsplace.x2,propsplace.y2,100,100);  
                propsplace.distance  =   Math.sqrt(Math.pow( ball.x - propsplace.x2,2) + Math.pow(ball.y - propsplace.y2,2) ); 
                if (propsplace.distance >= 100 ){
                    console.log("drawing the prop")
                    context.drawImage(propsimage,0,0,290,285,propsplace.x2,propsplace.y2,100,100);
                    
              }
                else if (propsplace.distance < 100){propsplace.draw=false;console.log("touched the prop!")}
                }
                
            t++;

            //context.drawImage(ball, 0, 0, 290,285,ball.x,ball.y,100,98);
            //context.drawImage(ball, 0, 0, 290,285,200,200,100,98);
            context.restore();
/*
            //以下为碰撞判断
            var between_x = (ball.x >= bbd_x) && (ball.x <= (bbd_x+bbd_w))
            var between_y = (ball.y <= bbd_y)&&(ball.y >= (bbd_y-bbd_h))
            var topclip = ((ball.y <= bbd_y+ball.r) && (between_x))
            var downclip = ((between) && (ball.y >= (bbd_y-ball.r)))
            //四角距离判定
            var distance = function(x,y){
                return (x-ball.x)*(x-ball.x) + (y-ball.y)*(y-ball.y)
            }
            var r_squar = ball.r*ball.r
            var connerClip_x = (distance(bbd_x,bbd_y) < r_squar) || (distance(bbd_x,bbd_y-bbd_h) < r_squar)
            var connerClip_y = (distance(bbd_x + bbd_w,bbd_y) < r_squar) || (distance(bbd_x + bbd_w) < r_squar)
            if (between_x && between_y){
                v_x= -(v_x-5)
            }
            else if ((!between_y) && (topclip)){
                v_y = -(v_y-5)
            }
            else if ((!between_y) && (downclip)){
                v_y = -(v_y + 5)
            }
            else if (connerClip_x || connerClip_y){
                v_x = -v_x
                v_y = -v_y
            }
            //篮板碰撞模块结束
            //篮框碰撞 直接上点碰撞且只有一种处理
            if ((distance(bkt_x-r,bkt_y) <= r_squar) || (distance(bkt_x+r) <= r_squar)){
                if ((ball.x <= bkt_x-bkt_r) && (ball.y >= bkt_y)){
                    v_x = -(v_x-5)
                    v_y = -(v_y-8)
                }
                else if ((ball.x <= bkt_x-bkt_r) && (ball.y <= bkt_y)){
                    //v_x = random left or right
                    v_y = -v_y
                }
                else if ((ball.x >= bkt_x-bkt_r) && (ball.y >= bkt_y)){
                    v_x = -(v_x-8)
                    v_y = -(v_y-5)
                }
                
            }*/

        }, 1000 *1/ (60*4));
        

    };


</script>
</body>
</html>
